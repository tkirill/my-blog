Title: Приступая к работе с Katana Project
Date: 2014-03-12
Slug: getting-started-with-katana
Author: tkirill
Summary: Перевод статьи о Katana project от руководителя разработки Web-инструментов Microsoft.

В 2002, когда впервые был выпущен ASP.NET, времена были другие.  Интернет всё ещё был в относительно младенческом состоянии, около 569 миллионов пользователей проводили в среднем 46 минут в день на приблизительно 3 миллионах сайтов.  Те же самые измерения, проведённые всего десятью годами позже, показывают приблизительно 2.27 миллиардов пользователей, в среднем тратящими ежедневно 4 часа на 555 миллионах сайтов (см. [bit.ly/MY7GzO](http://bit.ly/MY7GzO)).

Этот рост, конечно же, привёл к соответствующим изменениям в потребностях разработчиков в смысле фреймворков, инструментов и рантаймов, которые они используют для разработки и запуска веб-приложений.  Современные веб-приложения должны развиваться быстро, используя фишки из множества разных компонентов и фреймворков, а также использовать малое количество ресурсов, чтобы эффективно работать в больших облачных системах.

Главным мотивом для Katana Project является обеспечение того, чтобы ASP.NET мог ответить этим текущим и будущим потребностям.

Что такое Katana?
-----------------

Проект Katana на самом деле были начат не в Microsoft, а в open-source проекте Open Web Interface for .NET (OWIN), спецификации, которая определяет взаимодействие между веб-сервером и компонентами приложения (см. [owin.org](http://owin.org)).  Так как цель спецификации – стимулировать обширную и живую экосистему .NET-серверов и программных компонентов, то всё взаимодействие между сервером и приложением сводится к небольшому набору типов и единственной функции, известной как application delegate, или AppFunc:

    :::csharp
    using AppFunc = Func<IDictionary<string, object>, Task>;

Каждый компонент OWIN-приложения предоставляет серверу application delegate.  Затем компоненты сцепляются вместе в конвеер, в который OWIN-сервер посылает запросы.  Все компоненты в конвеере должны быть асинхронными, чтобы эффективно использовать ресурсы, и это отражено в application delegate, возвращающим Task.

Все состояния, включая состояния приложения, запроса, сервера и так далее, содержатся в `IDictionary<string, object>`, передаваемом в application delegate.  Эта структура данных, известная как environment dictionary, передаётся от компонента к компоненту по ходу того, как запрос проходит через конвеер.  Не отменяя того, что любые key/value данные могут быть вставлены в environment dictionary, спецификация OWIN определяет ключи для некоторых ключевых элементов HTTP.

| Ключ | Описание |
| ---- | -------- |
| "owin.RequestBody" | 	`Stream`-объект с телом запроса, если оно есть.  В случае, когда его нет, в качестве заглушки используется `Stream.Null`. |
| "owin.RequestHeaders" | `IDictionary<string, string[]>` с заголовками запроса. |
| "owin.RequestMethod" | Строка, содержащая HTTP-метод запроса (например, GET или POST). |
| "owin.RequestPath" | Строка, содержащая путь запроса.  Путь должен указываться относителено "корня" application delegate. |
| "owin.RequestPathBase" | Строка, содержащая часть пути запроса, соответствующую "корню" application delegate. |
| "owin.RequestProtocol" | Строка, содержащая название и версию протокола (например, HTTP/1.0 или HTTP/1.1). |
| "owin.RequestQueryString" | Строка, содержащая query string из урла HTTP-запроса, без "?" в начале (например, foo=bar&baz=quux). Может быть пустой строкой. |
| "owin.RequestScheme" | Строка, содержащая схему URI, использующуюся в запросе (например, HTTP or HTTPS). |

Закрепление базового набора key-value пар в environment dictionary даёт авторам множества разных фреймворков и компонентов возможность взаимодействовать внутри конвеера OWIN без навязывания соглашений о строгой модели .NET-объекта, вроде HttpContextBase в ASP.NET MVC или HttpRequestMessage/HttpResponseMessage in ASP.NET Web API.

Эти два элемента -- application delegate и environment dictionary -- и образуют спецификацию OWIN.  Katana -- это набор OWIN-компонентов и фреймворков, созданных и распростроняемых Microsoft.

Компоненты Katana можно отобразить в виде стека:

![Katana architectural stack](http://i.msdn.microsoft.com/dn451439.Dierking_Figure2_hires%28en-us,MSDN.10%29.png)

Стек состоит из следующих слоёв:

Host
:    Процесс, который запускает приложение и который может быть чем угодно: от IIS или отдельного исполняемого файла до вашей единственной и неповторимой программы.  Host отвечает за запуск, загрузку остальных компонентов OWIN и корректную остановку.

Server
:    Ответственен за привязку к TCP-порту, создание environment dictionary и передачу запросов в OWIN-конвеер.

Middleware
:    Под это название попадают все компоненты, обрабатывающие запросы в OWIN-конвеере.  Middleware может разнится от несложного компонента для сжатия до целого фреймворка вроде ASP.NET Web API, хотя с точки зрения сервера это всегда будет ни больше ни меньшев как просто компонент, который предоставляет application delegate.

Application
:    Это ваш код.  Так как Katana -- это не замена для ASP.NET, а новый способ объединять и запускать компоненты, то существующие ASP.NET Web API и SignalR приложения останутся без изменений, эти фреймворки умеют встраиватся в конвеер OWIN.  Фактически, для таких приложений Katana будет видна всего лишь как небольшой конфигурационный класс.

Архитектурно Katana разделена так, что каждый слой может быть легко заменён, часто без перекомпиляции кода.  При обработке HTTP-запроса слои работают вместе примерно так:

![katana-data-flow](http://i.msdn.microsoft.com/dn451439.Dierking_Figure3_hires\(en-us,MSDN.10\).png)

Создание современного веб-приложения с Katana
---------------------------------------------

Современные веб-приложения зачастую используют 4 вещи:

1. Серверная генерация разметки
2. Раздача статичных файлов
3. Web API для обработки AJAX запросов
4. Messaging в реальном времени

Для того, чтобы создать приложение со всеми этими возможностями, требуется несколько разных фреймворков, специально приспособленных для соответствующей функциональности.  Однако, составление приложения из таких фреймворков часто может оказаться трудным, и сейчас это требует хостинга различных частей приложения под IIS с возможной изоляцией их друг от друга с помощью applications и virtual directories.

В противоположность этому, Katana предлагает вам собрать современное веб-приложение, используя широкий набор разных веб-технологий, и затем захостить это приложение любым желаемым способом, выставив его под одним HTTP endpoint.  Это даёт несколько преимуществ:

* Простой деплой: он включает в себя единственное приложение вместо отдельных приложений для каждой технологии.
* Вы можете добавить другие возможности, например, аутентификацию, которая может быть применена ко всем нижележащим компонентам в конвеере.
* Разные компоненты, неважно, от Microsoft или сторонние, могут работать с одним и тем состоянием запроса через environment dictionary.

Теперь я пройдусь по примеру приложения из области, с который вы должны быть знакомы: баг-трекинг.  Приложение будет показывать набор багов в разных состояниях - отложен, в работе и сделан - и позволит мне перемещать баги между ними.  Также, так как одновременно работать с багом может множество разных людей, то приложение будет обновлять все браузеры в реальном времени при изменении состояния бага.  Вот что я буду использовать для построения приложения:

* Nancy ([nancyfx.org](http://nancyfx.org)) для серверной генерации разметки и раздачи статики.
* ASP.NET Web API ([asp.net/web-api](http://asp.net/web-api)) для обработки AJAX-запросов.
* SignalR ([signalr.net](http://signalr.net)) для обмена сообщениями в реальном времени.

Я не собираюсь тратить много времени на вёрстку и клиентские скрипты, поэтому дополнительно я буду использовать Knockout.js для отделения HTML-разметки от данных, поступающих из API и SignalR.

Главное, о чём стоит помнить - это то, что я собираю все эти фреймворки в один OWIN-конвеер, так что если мне станут доступны новые возможности, то я добавлю их в приложение простой вставкой их в конвеер.

Приступаем к работе
-------------------

Одна из целей Katana -- позволить вам лучше контролировать возможности, добавленные в ваше приложение (и, следовательно, ваши затраты в смысле ресурсов на обработку каждого запроса).  Помня об этом, я начну создавать новый пустой ASP.NET Web app проект в Visual Studio 2013:

![begin-creating-project](http://i.msdn.microsoft.com/dn451439.Dierking_Figure%204_hires\(en-us,MSDN.10\).png)

Шаблоны Web-проектов, даже пустые, помогают в том, что по-умолчанию складывают скомпилированные сборки прямо в каталог /bin вместо /bin/debug, что часто встречается в проектах других типов.  Стандартный Katana-хост ищет сборки в каталоге /bin.  Вы можете создать приложение, основанное на Katana, в виде библиотеки классов, но тогда вам придётся либо поменять свойства проекта так, чтобы они подходили под эту структуру, либо предоставить собственный специфический загрузчик приложений, который сможет отыскать сборки и типы в другой структуре каталогов.

Далее я сделаю серверную генерацию разметки с помощью веб-фреймворка Nancy.

Лаконичный синтаксис Nancy позволяет легко и быстро строить HTTP-сайты и сервисы.  Но что более важно для этого упражнения -- это то, что, подобно ASP.NET Web API, Nancy не зависит от System.Web.dll и приспособлен для запуска в конвеере OWIN.  Фреймворки вроде ASP.NET MVC имеют зависимости от System.Web.dll (на момент написания этой статьи), что делает их менее годными для хостинга вне IIS.

Зачастую, когда вы добавляете новый функционал в приложение, вы начинаете с установки NuGet пакета (вы можете прочитать подробнее про NuGet на [docs.nuget.org](http://docs.nuget.org)).  На момент написания многие используемые здесь пакеты находились в пре-релиз версиях, поэтому проверьте, что отображение пре-релиз пакетов включено в диалоговом окне NuGet.

Добавить Nancy в приложение я могу простой установкой одноимённого NuGet-пакета.  Однако, так как я хочу ещё запускать Nancy в конвеере OWIN, я установлю пакет Nancy.Owin ([nuget.org/packages/nancy.owin](http://nuget.org/packages/nancy.owin)).  Он установит пакет Nancy как зависимость и предоставит дополнительные хелперы для настройки Nancy в конвеере OWIN.

Затем мне нужно создать модуль Nancy (похож на контроллер из Model-View-Controller, или MVC) для обработки запросов, а также view для отображения чего-нибудь в браузере.  Вот код модуля (HomeModule.cs):

    :::csharp
    public class HomeModule : NancyModule
    {
      public HomeModule() {
        Get["/"] = _ => {
          var model = new { title = "We've Got Issues..." };
          return View["home", model];
        };
      }
    }

Как вы можете видеть, модуль говорит, что запросы на корень приложения ("/") должны быть обработаны анонимным делегатом, определённым в соответствующей лямбде.  Эта функция создаёт модель с заголовком страницы и говорит Nancy отрендерить view "home", передавая в неё модель. View, показанная ниже, вставляет заголовок из модели и в заголовок страницы, и в тег h1:

    :::html
    <!DOCTYPE html>
    <html >
    <head>
      <title>@Model.title</title>
    </head>
      <body>
        <header>
          <h1>@Model.title</h1>   
        </header>
        <section>
          <h2>Backlog</h2>
          <ul class="bugs" id="backlog">
            <li>a bug</li>
          </ul>
        </section>
        <section>
          <h2>Working</h2>
          <ul class="bugs" id="working">
            <li>a bug</li>
          </ul>
        </section>
        <section>
          <h2>Done</h2>
          <ul class="bugs" id="done">
            <li>a bug</li>
          </ul>
        </section>
      </body>
    </html>

За более подробной информацией об этих листингах загляните, пожалуйста, в документацию Nancy.

Теперь, когда у меня есть базовая функциональность Nancy, мне нужно организовать конвеер OWIN и встроить в него модуль Nancy.  Для этого мне нужно установить хост Katana и серверные компоненты, а затем написать немного кода для связки конвеера OWIN и Nancy.

В качестве хоста Katana и серверных компонентов я буду использовать IIS Express и System.Web, так как они имеют родную поддержку в Visual Studio и вдовабок позволяют использовать удобную кнопку F5 при разработке приложения.  Я добавлю System.Web-хост в проект с помощью установки NuGet-пакета Microsoft.Owin.Host.SystemWeb ([bit.ly/19EZ2Rw](http://bit.ly/19EZ2Rw)).

Стандартные компоненты Katana используют разные соглашения по загрузке и запуску OWIN-приложений, включая startup class.  Когда хост Katana загружает OWIN-приложение, он находит и запускает startup class согласно следующих правил (в порядке приоритета):

* Если Web.config содержит настройку с ключом "owin:AppStartup" в appSettings, то загрузчик возьмёт указанное значение.  Оно должно быть валидным именем .NET-типа.
* Если сборка содержит аттрибут `[assembly: OwinStartup(typeof(MyStartup))]`, загрузчик возьмёт указанный в нём тип.
* Если никакое из этих условий не сработает, то загрузчик пройдётся по всем загруженным сборкам в поиска типа Startup, у которого есть метод с сигнатурой `void Configure(IAppBuilder app)`.

Для этого примера я позволю загрузчику просканировать сборки в поисках класса.  Однако, будет разумным использовать appSettings или атрибут сборки во избежание ненужного сканирования в случае, когда в вашем проекте много типов и сборок.

Я создам startup class, который будет инициализировать мой OWIN-конвеер и добавлять Nancy как компонент конвеера.  Я создаю новый класс Startup и добавляю конфигурационный метод следующим образом:

    :::csharp
    public class Startup
    {
      public void Configuration(IAppBuilder app)
      {
        app.UseNancy();
      }
    }

UseNancy -- это extension method, доступный из NuGet-пакета Nancy.Owin.  Многие библиотеки middleware предоставляют похожие удобные extension methods, упрощающие процесс настройки, но вам никто не запрещает добавлять middleware с помощью метода Use у IAppBuilder.

На данном этапе вы можете запустить проект в Visual Studio использую F5 и посмотреть, что он хоть пока что и не заставляет ронять челюсть на пол, но вы уже имеете полно-функциональное веб-приложение.  Сейчас конвеер OWIN состоит из одного компонента, Nancy, как это показано ниже:

![OWIN pipeline with Nancy](http://i.msdn.microsoft.com/dn451439.Dierking_Figure6_hires\(en-us,MSDN.10\).png)

Добавляем данные с помощью ASP.NET Web API
------------------------------------------

Пока что HTML view состоит в основном из статичной разметки.  Сейчас я выдам пользователям реальные баги для работы.  Во многих современных веб-приложениях задача по доставке данных в клиентский браузер перешла от фреймворков для серверной генерации разметки (вроде Nancy) к отдельному API.  В этом случае браузер сразу же после загрузки HTML-страницы выполняет JavaScript, который данные из API и динамически строит HTML-разметку.

Я начну с разработки API на фреймворке ASP.NET Web API.  Как обычно, первым делом нужно установить NuGet-пакет.  Пакет этот называется Microsoft.AspNet.WebApi.Owin ([bit.ly/1dnocmK](http://bit.ly/1dnocmK)) и он позволит легко встроить ASP.NET Web API в мой OWIN-конвеер.  Фреймворк ASP.NET Web API установится как зависимость.  После установки, я создам простое API:

    :::csharp
    public class BugsController : ApiController
    {
      IBugsRepository _bugsRepository = new BugsRepository();

      public IEnumerable<Bug> Get()
      {
        return _bugsRepository.GetBugs();
      }

      [HttpPost("api/bugs/backlog")]
      public Bug MoveToBacklog([FromBody] int id)
      {
        var bug = _bugsRepository.GetBugs().First(b=>b.id==id);
        bug.state = "backlog";
        return bug;
      }

      [HttpPost("api/bugs/working")]
      public Bug MoveToWorking([FromBody] int id)
      {
        var bug = _bugsRepository.GetBugs().First(b => b.id == id);
        bug.state = "working";
        return bug;
      }

      [HttpPost("api/bugs/done")]
      public Bug MoveToDone([FromBody] int id)
      {
        var bug = _bugsRepository.GetBugs().First(b => b.id == id);
        bug.state = "done";
        return bug;
      }
    }

В API содержится метод для получения набора багов из репозитория, а также ещё несколько методов для перемещения багов между состояниями.  Гораздо больше информации по ASP.NET Web API можно найти на [asp.net/web-api](http://asp.net/web-api)

Теперь, когда у меня есть контроллер ASP.NET Web API, мне нужно добавить его к своему существующему OWIN-конвееру.  Для этого я просто добавляю следующие строчки в метод Configuration в моём startup class:

    :::csharp
    var config = new HttpConfiguration();
    config.MapHttpAttributeRoutes();
    config.Routes.MapHttpRoute("bugs", "api/{Controller}");
    app.UseWebApi(config);

Как и в случае с Nancy, пакет OWIN для ASP.NET Web API предоставляет extension method UseWebApi, который способствует простой интеграции ASP.NET Web API в мой существующий OWIN-конвеер.  Теперь он состоит из двух компонентов, ASP.NET Web API и Nancy, как показано ниже:

![owin-pipeline-two-components](http://i.msdn.microsoft.com/dn451439.Dierking_Figure8_hires\(en-us,MSDN.10\).png)

Если запрос, попавший в конвеер, подойдёт под одно из правил в роутинге ASP.NET Web API, то ASP.NET Web API обработает его и сгенерирует ответ.  В противном случае запрос продолжит своё движение по конвееру, где его поджидает Nancy.  Если ни один из компонентов конвеера не сможет обработать какой-нибудь запрос, то стандартные компоненты Katana вернут HTTP 404.

Сейчас у меня есть работающее ASP.NET Web API приложение, но к нему никто не обращается из домашней view.  Поэтому я добавлю код по получению данных из API и генерации списка багов в каждом из состояний: отложено, в работе и сделано.  Для этой задачи я использую преимущества Knockout.js, JavaScript Model-View-ViewModel (MVVM) библиотеки.  Больше информации о Knockout вы можете найти на [knockoutjs.com](http://knockoutjs.com).

Для того, чтобы динамически создавать HTML-разметку на клиенте с использованием Knockout, первым делом мне нужно затянуть все баги из ASP.NET Web API и создать viewModel, которую Knockout привяжет к HTML элементам.

    :::html
    <script>
      $(function () {
        var viewModel;
        $.getJSON('/api/bugs', function(data) {
          var model = data;
          viewModel = {
            backlog: ko.observableArray(
              model.filter(function(element) { return element.state === 'backlog'; })),
            working: ko.observableArray(
              model.filter(function(element) { return element.state === 'working'; })),
            done: ko.observableArray(
              model.filter(function(element) { return element.state === 'done'; })),
            changeState: function (bug, newState) {
              var self = this;
              $.post('/api/bugs/' + newState, { '': bug.id }, function(data){
                self.moveBug(data);
              });
            },
            moveBug: function (bug) {
              // Remove the item from one of the existing lists
              ...
              // Add bug to correct list
              this[bug.state].push(bug);
            }
          };
          ko.applyBindings(viewModel);
        })
      })
    </script>

Как только viewModel создана, Knockout может динамически создавать и обновлять содержимое HTML через привязку viewModel к HTML элементам, к которым добавлены специальные атрибуты.  Например, список отложенных багов может быть сгенерирован из viewModel с помощью таких атрибутов:

    :::html
    <section>
      <h2>Backlog</h2>
      <ul class="bugs" id="backlog" data-bind="foreach:backlog">
        <li>
          [<span data-bind="text: id"></span>] <span data-bind="text: title"></span>:
            <span data-bind="text: description"></span>
          <ul>
            <li><a href="#" data-bind="click: $root.changeState.bind($root, $data, 'working')">Move to working</a></li>   
            <li><a href="#" data-bind="click: $root.changeState.bind($root, $data, 'done')">Move to done</a></li>   
          </ul>
        </li>
      </ul>
    </section>

Добавление моментальных оповещений об изменениях
------------------------------------------------------

Сейчас у меня есть полностью рабочее одностраничное веб-приложение.  Пользователи могут заходить на домашнуюю страницу и перемещать баги между разными состояниями.  Более того, технологии, на которых всё это работает, Nancy и ASP.NET Web API, работают вместе в одном OWIN-конвеере.

Но я собираюсь пойти дальше и сделать так, чтобы разные пользователи могли в реальном времени видеть обновления, сделанные другими пользователями.  Для этого я буду использовать библиотеку SignalR, которая предоставляет клиентское и серверное API для обмена сообщениями между браузером и веб-сервером в реальном времени.  SignalR тоже написан с учётом работы в OWIN-конвеере, поэтому добавить его к моему существующему приложению будет легче пареной репы.

Я буду использовать одну из возможностей SignalR под названием Hubs.  В двух словах, Hub позволяет клиентам и серверам вызывать методы друг друга.  Отличную вводную статью по SignalR можно посмотреть на [bit.ly/14WIx1t](http://bit.ly/14WIx1t).  В моём приложении, ASP.NET Web API при заросе на изменение состояния бага будет обновлять его и затем рассылать обновлённый баг через SignalR Hub во все клиентские браузеры, подсоединённые к приложению.

Я начну с созданию Hub на сервере.  Я не использую никаких других возможностей SignalR и поэтому мой Hub будет состоять всего лишь из такого пустого класа:

    :::csharp
    [HubName("bugs")]
    public class BugHub : Hub
    {
    }

Для того, чтобы что-нибудь послать в Hub из ASP.NET Web API, мне для начала нужно получить экземпляр его runtime context.  Я могу сделать это, добавив следующий код в конструктор BugsController:

    :::csharp
    public BugsController()
    {
      _hub = GlobalHost.ConnectionManager.GetHubContext<BugHub>();
    }

Затем я могу разослать обновлённый баг ко всем подсоединённым клиентским бразуером из какого-нибудь метода MoveToXX:

    :::csharp
    _hub.Clients.All.moved(bug);

На домашней странице, после добавления нескольких JavaScript библиотек SignalR, я могу подсоединиться к bugsHub и начать ждать сообщений об изменениях:

    :::js
    $.connection.hub.logging = true;
    var bugsHub = $.connection.bugs;
    bugsHub.client.moved = function (item) {
      viewModel.moveBug(item);
    };
    $.connection.hub.start().done(function() {
      console.log('hub connection open');
    });

Заметьте, что когда я получаю с сервера запрос через функцию moved, я вызываю метод moveBug у viewModel также, как я делал это в обработчике клика на элемент списка.  Разница в том, что все клиентские браузеры могут одновременно обновить свои viewModel, так как этот вызов производится через SignalR.  Вы можете убедиться в этом, открыв два окна браузера.  Изменения, сделанные в одном окне, отобразятся в другом.

Как я говорил, добавление SignalR в OWIN-конвеер тривиально.  Я просто добавляю следующий код в метод Configuration у startup class:

    :::csharp
    app.MapSignalR();

Всё это создаёт такой конвеер:

![owin-pipeline-three-elements](http://i.msdn.microsoft.com/dn451439.Dierking_Figure11_hires\(en-us,MSDN.10\).png)

Переходим к self-host
---------------------

На текущий момент у меня есть работающее приложение по управлению багами, и, хотя ему всё ещё не хватает нескольких важных возможностей, оно уже может делать пару интересных вещей.  Я постепенно добавлял к приложению функциональные блоки, используя как Microsoft-, так и сторонние middleware компоненты.  Справедливо заметить, что многое из этого можно было сделать и с помощью ASP.nET HttpModules и HttpHandlers.  Так чего же я действительно достиг, кроме более простого, ориентированного на код подхода для составления компонентов конвеера вместе?

Для ответа на этот вопрос нужно вспомнить общую схему архитектуры Katana из начала статьи.  До этого момента, я работал только с верхними двумя уровнями стека Katana.  Однако, все эти слои могут быть с лёгкостью заменены, включая сервер и хост.

Чтобы продемонстрировать это, я возьму весь свой конвеер, выкину IIS и System.Web.dll и поставлю всё поверх простого, легковесного HTTP-сервера, который будет хоститься с помощью OwinHost.exe, входящего в состав Katana.  Self-hosting может оказаться полезным в разных сценариях, от случаев, когда на машине разработчика нет Web-сервера, до боевого деплоя на shared-хостинге, который использует изоляцию процессов и не даёт доступа к Web-серверу.

Начну я с установки следующих NuGet пакетов:

* Microsoft.Owin.Host.HttpListener ([bit.ly/153aIca](http://bit.ly/153aIca))
* OwinHost ([bit.ly/162Uzj8](http://bit.ly/162Uzj8))

Затем я сделаю ребилд приложения.  Заметьте, что не обязательно делать ребилд для того, чтобы запустить приложения поверх новых сервера и хоста.  Единственным требованием является наличие их файлов в каталоге /bin, а ребилд -- всего лишь удобный способ скопировать эти файлы в /bin.

После того, как пакеты установлены и файлы скопированы, я открываю командную строку, перехожу в корневой каталог веб-проекта и, как это показано ниже, запускаю OwinHost.exe из каталога packages:

    :::bat
    ..\packages\OwinHost.2.0.0\tools\OwinHost.exe

![calling OwinHost.exe](http://i.msdn.microsoft.com/dn451439.Dierking_Figure%2012_hires\(en-us,MSDN.10\).png)

По-умолчанию, OwinHost.exe запустится, загрузит сервер Microsoft.Owin.Host.HttpListener и начнёт слушать порт 5000.  Я могу зайти на http://localhost:5000 и убедиться в том, что приложение работает.

Более того, практически всё настройки могут быть изменены через аргументы командной строки.  Например, если вы хотите слушать на другом порту, передайте -p 12345.  Если вы хотите использовать совершенно другой сервер, передайте -s your.custom.server.assembly.  Сила архитектуры Katana -- модульность.  Как только появилось что-то новое на каком-то уровне стека, оно может быть без промедлений затянуто в работающее приложение.  А так как контракт между всеми компонентами стека -- это всего лишь application delegate, то темп этих изменений может быть гораздо большим, чем это возможно сейчас.

Просто начните использовать
---------------------------

Katana 2.0 будет выпущена вместе с Visual Studio 2013.  В новой версии сконцентрировались на двух главных вещах:

* Предоставление основных инфраструктурных компонентов для self-hosting.
* Предоставление богатого набора middleware для аутентификации, включая социальные провайдеры, такие как Facebook, Google, Twitter и Microsoft Account, а также провайдеры для Windows Azure Active Directory, куков и federation (_наверное, речь об этом: [msdn.microsoft.com/en-us/library/ms730908%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/ms730908%28v=vs.110%29.aspx) --- прим. перевод._).

Как только Katana 2.0 зарелизится, сразу же начнётся работа над следующим набором компонентов Katana.  Детали и приоритеты всё ещё определяются, но вы можете повлиять на обсуждение через заполнение issues на [katanaproject.codeplex.com](http://katanaproject.codeplex.com).  Наконец, весь код из статьи доступен на [bit.ly/1alOF4m](http://bit.ly/1alOF4m).

----------

_Howard Dierking работает на должности program manager в команде Windows Azure Frameworks and Tools, где он сосредоточен на ASP.NET, NuGet и Web API.  Ранее Dierking был редактором MSDN Magazine, а также занимался программой сертификации разработчиков для Microsoft Learning.  До Microsoft он 10 лет был разработчиком и архитектором приложений с уклоном на распределённые системы._

----------

**От переводчика**
В заключение хочу поделиться собственными мыслями по поводу Katana.  В первую очередь меня заинтересовало то, как в Katana используется ASP.NET Identity, новая система аутентификации и авторизации, появившаяся вместе с MVC 5 и остальными октябрьскими релизами в 2013 году.  Identity чертовски просто встраивается в конвеер:

    :::csharp
    appBuilder.UseGoogleAutentification()

Но есть и подозрительные моменты.  Конечно, сложно спорить с Howard Dierking, управляющим разработкой фреймворков, про которые написано столько книг и статей, что отдельным достижением является прочтение хотя бы половины из них.  Но, с высоты моего скромного опыта, по крайней мере один из аргументов в пользу Katana воспринимается не так однозначно -- возможность собрать все сервисы в одно приложение и деплоить всё сразу.  Ведь известен совершенно противоположный подход -- разделить приложение на отдельные сервисы и получить возможность независимо и постепенно выкладывать обновления на боевую площадку.

Также, могут возникнуть сложности с поиском места в коде, отвечающим за ту или иную функциональность.  Когда запрос может быть обработан кучей разных компонентов и то, какой из них всё-таки отработает, зависит от порядка в конфигурации конвеера и специфичных для каждого компонента настройках, вроде конфига путей в Web API -- искать можно долго.
